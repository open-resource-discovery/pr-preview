"use strict";(self.webpackChunk_open_resource_discovery_specification=self.webpackChunk_open_resource_discovery_specification||[]).push([[9712],{659:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"spec-v1/concepts/compatibility","title":"Compatibility","description":"Compatibility concepts in ORD","source":"@site/docs/spec-v1/concepts/compatibility.md","sourceDirName":"spec-v1/concepts","slug":"/spec-v1/concepts/compatibility","permalink":"/pr-preview/specification/pr-66/spec-v1/concepts/compatibility","draft":false,"unlisted":false,"editUrl":"https://github.com/open-resource-discovery/specification/tree/main/docs/spec-v1/concepts/compatibility.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"Compatibility concepts in ORD"},"sidebar":"specV1Sidebar","previous":{"title":"System Landscape Model","permalink":"/pr-preview/specification/pr-66/spec-v1/concepts/system-landscape-model"},"next":{"title":"Class Diagrams","permalink":"/pr-preview/specification/pr-66/spec-v1/diagrams/"}}');var s=t(4848),r=t(8453);const o={sidebar_position:6,description:"Compatibility concepts in ORD"},a="Compatibility",c={},l=[{value:"Summary",id:"summary",level:2},{value:"Compatibility from Consumer Perspective",id:"compatibility-from-consumer-perspective",level:2},{value:"Abstract ORD Resources",id:"abstract-ord-resources",level:2},{value:"Compatible With Concept for ORD Resources",id:"compatible-with-concept-for-ord-resources",level:2},{value:"Purpose and Usage",id:"purpose-and-usage",level:3},{value:"Maximum Version and Contract Evolution",id:"maximum-version-and-contract-evolution",level:3}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"compatibility",children:"Compatibility"})}),"\n",(0,s.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(i.p,{children:"ORD's compatibility concept enables robust versioning and interface-based development across distributed systems. It encompasses three key aspects:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Semantic versioning and backward compatibility"}),": Resources follow semantic versioning principles, allowing consumers to safely upgrade within major versions while providers maintain flexibility to evolve their offerings."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Abstract resources"}),": Interface-only resources that define contracts without direct instantiation, similar to abstract classes in object-oriented programming."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsxs)(i.strong,{children:["The ",(0,s.jsx)(i.code,{children:"compatibleWith"})," property"]}),": Declares compatibility relationships between resources, enabling alternative implementations and standardized interface adoption."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Together, these mechanisms support flexible system integration while maintaining clear compatibility guarantees for consumers."}),"\n",(0,s.jsx)(i.h2,{id:"compatibility-from-consumer-perspective",children:"Compatibility from Consumer Perspective"}),"\n",(0,s.jsxs)(i.p,{children:["ORD resources follow ",(0,s.jsx)(i.a,{href:"https://semver.org/",children:"Semantic Versioning 2.0.0"})," principles. Consumers of API Resources, Event Resources, or Data Product Resources expect backward compatibility within major versions. This expectation forms the foundation of reliable system integration."]}),"\n",(0,s.jsx)(i.p,{children:"Providers can introduce compatible changes in minor and patch versions. Such changes include adding new optional fields, updating metadata, enhancing documentation, or introducing new optional functionality. These changes MUST NOT break existing consumers relying on previous versions within the same major version. Consumers can safely ignore newly added optional fields without any impact on their integration."}),"\n",(0,s.jsxs)(i.p,{children:["However, consumers may require functionality only available starting with a specific version of a resource. For example, a consumer might need a new field in an API that was introduced in version 1.2.0. In such cases, consumers can express their minimum version requirement explicitly via ",(0,s.jsx)(i.a,{href:"/pr-preview/specification/pr-66/spec-v1/concepts/integration-dependency",children:(0,s.jsx)(i.code,{children:"integrationDependency"})})," using the ",(0,s.jsx)(i.code,{children:"minVersion"})," property inside the integration dependency aspect. This declares that the consumer expects the provider to process information according to the specified minimum version."]}),"\n",(0,s.jsx)(i.p,{children:"When providers need to introduce breaking changes\u2014such as removing fields, changing field types, altering required parameters, or modifying fundamental behavior\u2014they MUST increment the major version number. Consumers relying on previous major versions will not be affected by such changes, as they represent distinct contracts. This allows providers to evolve their resources while maintaining support for existing consumer integrations."}),"\n",(0,s.jsx)(i.h2,{id:"abstract-ord-resources",children:"Abstract ORD Resources"}),"\n",(0,s.jsx)(i.p,{children:"Abstract ORD resources serve as interfaces, allowing others to provide resources that implement the interface by declaring compatibility with the abstract resource's contract. This enables standardization across different implementations while maintaining flexibility in how the interface is realized. Abstract resources indicate that the resource serves as an interface only and cannot be called directly. This concept mirrors the abstract keyword in programming languages like Java, where abstract classes define contracts that concrete implementations must fulfill."}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"abstract"})," property is available for API Resources, Event Resources, and Data Product Resources to indicate interface-only resources. When set to ",(0,s.jsx)(i.code,{children:"true"}),", this boolean flag signifies that the resource is an abstract representation and cannot be instantiated or consumed directly. Instead, the abstract resource defines the contract that other concrete resources can implement through the ",(0,s.jsx)(i.a,{href:"#compatible-with-property",children:(0,s.jsx)(i.code,{children:"compatibleWith"})})," property."]}),"\n",(0,s.jsx)(i.p,{children:"Abstract resources are particularly useful in scenarios where:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Multiple systems need to provide functionally equivalent resources following a common interface"}),"\n",(0,s.jsx)(i.li,{children:"A standardized contract needs to be defined across different implementation contexts"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"compatible-with-concept-for-ord-resources",children:"Compatible With Concept for ORD Resources"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"compatibleWith"})," property enables API Resources, Event Resources, and Data Product Resources to declare compatibility with other resources. This property serves two primary purposes: implementing abstract ORD resources and indicating compatibility with concrete resources."]}),"\n",(0,s.jsx)(i.h3,{id:"purpose-and-usage",children:"Purpose and Usage"}),"\n",(0,s.jsxs)(i.p,{children:["Resources use ",(0,s.jsx)(i.code,{children:"compatibleWith"}),' to reference an interface contract (typically an abstract resource) that they implement. This serves as a declaration of compatible implementation, effectively functioning as an "implementationOf" relationship. The data that compatible resources return follow the same schema, but the actual data itself can be different. For example, if one API returns 1 record for a specific request, a compatible API could return multiple and different records, as long as they adhere to the same schema.']}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"compatibleWith"})," property MUST contain a valid reference to an (usually external) API Resource, Event Resource, or Data Product Resource ORD ID. All resources that share the same ",(0,s.jsx)(i.code,{children:"compatibleWith"})," value MAY be treated as equivalent or similar by consumer clients, as they implement the same interface contract."]}),"\n",(0,s.jsxs)(i.p,{children:["Beyond implementing abstract resources, ",(0,s.jsx)(i.code,{children:"compatibleWith"})," can also indicate compatibility with other concrete resources. This scenario occurs when an alternative implementation of an existing resource is provided. Within larger projects, this might involve integrating third-party solutions through proxy implementations to be compatible with requirements of existing solutions."]}),"\n",(0,s.jsx)(i.h3,{id:"maximum-version-and-contract-evolution",children:"Maximum Version and Contract Evolution"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"maxVersion"})," property specifies the maximum version of the interface contract that a resource is compatible with. This is critical for maintaining clear compatibility boundaries as interface contracts evolve over time."]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"maxVersion"})," is the version that a developer has known and was probably the latest available version of the interface contract at the time of implementation. It indicates that the resource fully implements and supports the specified version of the contract."]}),"\n",(0,s.jsxs)(i.p,{children:["Even if an interface contract evolves in a backward-compatible manner (minor or patch version increments), a resource will not automatically be compatible with versions beyond its specified ",(0,s.jsx)(i.code,{children:"maxVersion"}),". This explicit boundary prevents assumptions about compatibility with future interface versions that may introduce optional features or enhancements that the implementing resource does not support."]}),"\n",(0,s.jsx)(i.p,{children:"Consider an API contract at version 1.0 that defines fields A and B. Another API resource declaring compatibility with version 1.0 means it implements exactly fields A and B, along with any tenant-specific extensions in a dedicated namespace. If the API contract changes to version 1.1 by adding optional field C, the API resource declaring compatibility with version 1.0 will not include field C. Only by adopting the contract of version 1.1 and implementing fields A, B, and C would the resource also be compatible with version 1.1 of the contract."}),"\n",(0,s.jsx)(i.p,{children:"However, a consumer client relying on version 1.0 of the contract can still work with a resource that declares compatibility with version 1.1 of the contract. The consumer will simply use the subset of fields (A and B) defined in version 1.0, ignoring the additional field C. This demonstrates how semantic versioning enables flexible compatibility relationships while maintaining clear boundaries."}),"\n",(0,s.jsxs)(i.p,{children:["Following the ",(0,s.jsx)(i.a,{href:"https://semver.org/",children:"Semantic Versioning 2.0.0"})," standard, patch versions (x.y.Z) MUST NOT have impact on the schema or contract. Therefore, the ",(0,s.jsx)(i.code,{children:"maxVersion"})," includes only the major.minor parts of a semantic version. Patch-level changes represent bug fixes and non-functional improvements that do not affect the interface contract itself."]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"maxVersion"})," mechanism ensures that:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Implementing resources explicitly state which version of an interface they support"}),"\n",(0,s.jsx)(i.li,{children:"Consumers can determine whether a resource supports the interface features they require"}),"\n",(0,s.jsx)(i.li,{children:"Interface contract owners can evolve their contracts without breaking existing implementations"}),"\n",(0,s.jsx)(i.li,{children:"Clear boundaries exist for compatibility relationships as systems evolve over time"}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>o,x:()=>a});var n=t(6540);const s={},r=n.createContext(s);function o(e){const i=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);